---
title: 算法训练之字符串
date: 2020-05-03
categories:
  - 数据结构与算法
tags:
  - leetcode
  - 算法（字符串）
---

::: tip
- 整数反转
- 有效的字母异位词
- 字符串转换整数
- 外观数列
- 反转字符串
- 字符串中第一个唯一字符
- 验证回文串
- 实现 strStr()
- 最长公共前缀
- 最长回文子串
:::

<!-- more -->

## 整数反转 - 简单

::: tip
[leetcode-7](https://leetcode-cn.com/problems/reverse-integer/)
:::

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转

数值范围为[-2^31, 2^31 - 1]，溢出返回 0

```js
示例1:
输入: 123
输出: 321

示例2:
输入: -123
输出: -321

示例3:
输入: 120
输出: 21
```

### 方法1：翻装字符串

```js
/**
 * @param {number} x
 * @return {number}
 */
const reverse = (x) => {
  // 非空判断
  if (typeof x !== 'number') {
    return;
  }

  // 极值
  const MAX = Math.pow(2, 31) - 1;
  const MIN = Math.pow(-2, 31);

  // 识别数字部分并反转
  const rest = x > 0
    ? String(x)
      .split('')
      .reverse()
      .join('')
    : String(x)
      .slice(1)
      .split('')
      .reverse()
      .join('')

  // 根据正负转换为正常值
  const result = x > 0 ? parseInt(rest, 10) : 0 - parseInt(rest, 10);

  // 边界情况
  if (result >= MIN && result <= MAX) {
    return result;
  }
  return 0;
}
```

- 时间复杂度: O(n)，n 为整数长度
- 空间复杂度: O(n)，新创建 String 对象，n 为 整数长度

### 方法2：类似欧几里得算法

```js
/**
 * @param {number} x
 * @return {number}
 */
const reverse = (x) => {
  // 获取绝对值
  let int = Math.abs(x);

  // 极值
  const MAX = Math.pow(2, 31) - 1;
  const MIN = Math.pow(-2, 31);

  let num = 0;

  while (int !== 0) {
    // 模 10 取到最低位，再乘 10 迭代到最高位
    num = (int % 10 ) + num * 10;
    // 剔除被消费的部分
    int = Math.floor(int / 10);
  }

  if (x < 0) {
    num = num * -1;
  }

  if (num >= MIN && num <= MAX) {
    return num;
  }

  return 0;
}
```

- 时间复杂度: O(n)，n 为整数长度
- 空间复杂度: O(1)，只用到常数个变量

## 有效的字母异位词 - 简单

::: tip
[leetcode-242](https://leetcode-cn.com/problems/valid-anagram/)
:::

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

```js
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```

### 方法1：利用数组 sort

转为数组进行排序，再转为字符串进行比较

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
const isAnagram = (s, t) => {
  const sArr = s.split('');
  const tArr = t.split('');
  const sortFn = (a, b) => {
    return a.charCodeAt() - b.charCodeAt();
  };

  sArr.sort(sortFn);
  tArr.sort(sortFn);

  return sArr.join('') === tArr.join('');
}
```

- 时间复杂度: O(nlogn)，JS 数组 sort 实现原理，当数组长度小于等于 10 时，采用插入排序，大于 10 采用快速排序，快排复杂度为 O(nlogn)
- 空间复杂度: O(n)，申请了两个数组存放字符串

### 方法2：计数累加

声明一个对象记录字符串的个数，另一个字符串每项与对象做匹配，判断计数是否相等

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
const isAnagram = (s, t) => {
  if (s.length !== t.length) return false;

  const hash = {};
  for (const k of s) {
    hash[k] = hash[k] || 0;
    hash[k] += 1;
  }

  for (const k of t) {
    if (!hash[k]) return false;
    hash[k] -= 1;
  }

  return true;
}
```

- 时间复杂度: O(n)，两个单层循环
- 空间复杂度: O(1)，申请的变量 hash 最大长度为 256，因为 Ascii 字符最多 256 种可能，因此，考虑为常量空间，即 O(1)

## 字符串转换整数 - 中等

::: warning
[leetcode-8](https://leetcode-cn.com/problems/string-to-integer-atoi/)
:::

请你来实现一个 atoi(ascii to integer)) 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

- 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
- 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
- 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

提示：

- 本题中的空白字符只包括空格字符 ' '
- 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31)

```js
示例1:
输入: "42"
输出: 42

示例2:
输入: "-42"
输出: -42

示例3:
输入: "4193 with words"
输出: 4193

示例4:
输入: "words and 987"
输出: 0

示例5:
输入: "-91283472332"
输出: -2147483648
```

### 方法1：正则匹配

使用正则提取满足条件的字符， `/^(-|\+)?\d+/g` ， `(-|\+)?` 表示第一位是`-`或`+`或`都不是`， `\d+` 表示匹配多个数字

```js
/**
 * @param {string} str
 * @return {number}
 */
const myAtoi = function (str) {
  const result = str.trim().match(/^(-|\+)?\d+/g);

  return result
    ? Math.max(Math.pow(-2, 31), Math.min(Math.pow(2, 31) - 1, Number(result[0])) // 边界判断
    : 0;
}
```

- 时间复杂度: O(1)，消耗的时间不随着变量增长而增长
- 空间复杂度: O(1)

### 方法2：逐个判断

- 去除空格
- 判断是否为数字
- 判断是否超过 min 或 max

```js
/**
 * @param {string} str
 * @return {number}
 */
const myAtoi = function (str) {
  // 去除空格
  const news = str.trim();

  // 判断是否为数字
  const num = parseInt(news, 10);
  if (num) {
    return Math.max(Math.pow(-2, 31), Math.min(Math.pow(2, 31) - 1, num));
  } else {
    return 0;
  }
}
```

- 时间复杂度: O(1)，消耗的时间不随着变量增长而增长
- 空间复杂度: O(1)，额外分配空间不随着处理数据量变化

## 外观数列 - 简单

::: tip
[leetcode-38](https://leetcode-cn.com/problems/count-and-say/)
:::

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

```
1
11
21
1211
111221
```

- 1 被读作  "one 1"  ("一个一") , 即 11。
- 11 被读作 "two 1s" ("两个一"）, 即 21。
- 21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。

```js
输入:1
输出: "1"

输入:4
输出: "1211"
```

### 方法1：递归法

获取第 n 项，就要获取第 n - 1 项，然后报出第 n - 1 项结果即可

```js
/**
 * \d 匹配一个数字
 * \1 匹配前第一个括号内匹配的内容
 * (\d)\1* 匹配相邻数字相同的内容
 */
'111221'.match(/(\d)\1*/g)

// ["111", "22", "1"]
```

```js
/**
 * @param {number} n
 * @return {string}
 */
const countAndSay = function (n) {
  if (n === 1) return '1';

  const preResult = countAndSay(n - 1); // 获取第 n-1 项的结果

  // 使用 replace 将匹配的内容处理为 长度 + 内容的第一个字符
  return preResult.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`);
}
```

- 时间复杂度: O(n)，方法调用次数为 n
- 空间复杂度: O(n)，每调用一次会申请新的内存空间，随 n 线性增加

### 方法2：循环法

递归法为从 n 到 1 计算相应的值，循环法为从 1 计算到 n

```js
/**
 * @param {number} n
 * @return {string}
 */
const countAndSay = function (n) {
  let result = '1'; // 第一个数为 ‘1’

  for (let i = 1; i < n; i++) { // 循环到第 n 项
    result = result.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`); // 同方法 1
  }

  return result;
}
```

- 时间复杂度: O(n)，方法调用次数为 n
- 空间复杂度: O(1)，额外分配空间为固定值


## 反转字符串 - 简单

::: tip
[leetcode-344](https://leetcode-cn.com/problems/reverse-string/)
:::

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

```js
输入: ["h","e","l","l","o"]
输出: ["o","l","l","e","h"]


输入: ["H","a","n","n","a","h"]
输出: ["h","a","n","n","a","H"]
```

### 方法：首尾替换法

逐位遍历，进行交换

- 第 i 位与倒数 i 位交换
- i + 1，继续替换
- 直到 i 大于长度中位数

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
const reverseString = function (s) {
  for (let i = 0; i < s.length / 2; i ++) {
    [s[i], s[s.length - 1 - i]] = [s[s.length - 1 - i], s[i]]; // es6 解构赋值
  }
};
```

时间复杂度: O(n)，字符串长度为 n，n 为偶数，遍历 n/2 次，n 为奇数，遍历 (n + 1)/2 次
空间复杂度: O(1)

## 字符串中第一个唯一字符 - 简单

::: tip
[leetcode-387](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)
:::

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

```js
s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.
```

### 方法1：库函数

判断每个位置的字符的 index() 和 lastIndexOf() 的结果是否相等

```js
/**
 * @param {string} s
 * @return {number}
 */
const firstUniqChar = function (s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
}
```

时间复杂度: O(n^2)，外层遍历为 O(n)，调用 `indexOf` 为 O(n)，总复杂度为 O(n^2)
空间复杂度: O(1)

### 方法2：哈希表

- 第一次遍历，用哈希表记录出现的次数
- 第二次遍历，找出 hash 表中只出现一次的字符下标

```js
/**
 * @param {string} s
 * @return {number}
 */
const firstUniqChar = function (s) {
  const hash = {};

  for (let i = 0; i < s.length; i++) {
    if (hash[s[i]]) {
      hash[s[i]]++
    } else {
      hash[s[i]] = 1;
    }
  }

  for (let i = 0; i < s.length; i++) {
    if (hash[s[i]] === 1) return i;
  }

  return -1;
}
```

时间复杂度: O(n)，只有两次遍历
空间复杂度: O(1)，申请的 hash 大小不随输入变量量变化

## 验证回文串 - 简单

::: tip
[leetcode-125](https://leetcode-cn.com/problems/valid-palindrome/)
:::

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

```js
输入: "A man, a plan, a canal: Panama"
输出: true

输入: "race a car"
输出: false
```

### 方法一

去除非字母和数字，再转换为数组，再对数组首尾一一比较

```js
/**
 * @param {string} s
 * @return {boolean}
 */
const isPalindrome = function(s) {
  // 将传入的字符串,去除非字母和数字,统一转化为小写,再转换为数组
  const arr = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase().split('');

  let i = 0;
  let j = arr.length - 1;

  while(i < j) {
    if (arr[i] !== arr[j]) return false;
    i++;
    j--;
  }

  return true;
};
```

时间复杂度: O(n), 循环最多执行 n/2 次
空间复杂度: O(n), 申请了一个长度为 n 的数组

### 方法二

去除非字母和数字，再转换为数组，利用数组翻转字符串与原字符串比较

```js
/**
 * @param {string} s
 * @return {boolean}
 */
const isPalindrome = function(s) {
  // 将传入的字符串,去除非字母和数字,统一转化为小写,再转换为数组
  const arr = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase().split('');

  return arr.join('') === arr.reverse().join('');
};
```

时间复杂度: O(n)，`toLowerCase()`，`replace()`，`split()`，`reverse()`，`join()` 时间复杂度都为 O(n)，都在独立的循环中执行，因此总时间复杂度为 O(n)
空间复杂度: O(n)，申请了一个长度为 n 的数组

## 实现 strStr() - 简单

::: tip
[leetcode-28](https://leetcode-cn.com/problems/implement-strstr/)
:::

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

```js
输入: haystack = "hello", needle = "ll"
输出: 2

输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

### 方法1：遍历截取字符串对比

从 haystack 中截取与 needle 长度相等的内容进行对比

- needle 长度为 0，直接返回 0
- needle 长度大于 haystack，直接返回 -1
- needle 长度等于 haystack，比较两个字符串是否相等即可
- needle 长度小于 haystack，遍历 haystack，若 haystack 剩余长度小于 needle，则无需再遍历，进行内容对比时如果首位字符不相同，则无需再比较后续，直接进入下一次循环

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
const strStr = function (haystack, needle) {
  const hayLen = haystack.length;
  const nedLen = needle.length;

  if (!nedLen) {
    return 0;
  } else if (nedLen > hayLen) {
    return -1;
  } else if (nedLen === hayLen) {
    return haystack === needle ? 0 : -1;
  } else {
    for(let i = 0; i <= hayLen - nedLen; i++) {
      if (haystack[i] !== needle[0]) {
        continue;
      }

      if (haystack.substring(i, i + nedLen) === needle) {
        return i;
      }
    }
  }

  return -1;
};
```

时间复杂度: O(n)，遍历长度可能为 1 到 n - 1，概率均等，则为 (n - 1 + 1) / 2 即 O(n)
空间复杂度: O(1)，只使用了 hayLen 和 nedLen 两个额外空间

### 方法2：双层循环对比

从 haystack 不同位置开始遍历，判断其中是否有 needle

边界情况处理与方法 1 一致

遍历 haystack 过程：
 - 先判断本次遍历首尾是否与 needle 相同，不相同则进入下次遍历
 - 对比 haystack 本次遍历不同位置字符是否与 needle 相同

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
const strStr = function (haystack, needle) {
  const hayLen = haystack.length;
  const nedLen = needle.length;

  if (!nedLen) {
    return 0;
  } else if (nedLen > hayLen) {
    return -1;
  } else if (nedLen === hayLen) {
    return haystack === needle ? 0 : -1;
  } else {
    for(let i = 0; i <= hayLen - nedLen; i++) {
      if (haystack[i] === needle[0] && haystack[i + nedLen - 1] === needle[nedLen - 1]) {
        if (nedLen === 1) return i;

        for (let j = 1; j < nedLen; j++) {
          if (haystack[i + j] !== needle[j]) {
            break;
          }
          if (j === nedLen - 1) {
            return i;
          }
        }
      }
    }
  }

  return -1;
};
```

时间复杂度: O(n^2)，假设当字符串长度为 n，待比较字符串长度为 n - 1，需要对比 n * (n - 1) 次为 n^2 - n 即 O(n^2)
空间复杂度: O(1)

## 最长公共前缀 - 简单

::: tip
[leetcode-14](https://leetcode-cn.com/problems/longest-common-prefix/)
:::

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""

```js
输入: ["flower","flow","flight"]
输出: "fl"

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

### 方法1：递归迭代

- 查找前 n - 1 个字符串的公共前缀 m
- 查找 m 与最后一个字符串 n 的公共前缀

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
const longestCommonPrefix = function (strs) {
  let commonPrefix = '';
  if (strs.length > 0) {
    let commonPrefix = strs[0];
    for (let i = 1; i < strs.length; i++) {
      commonPrefix = findCommonPrefix(commonPrefix, strs[i]);
    }
  }

  return commonPrefix;
};

function findCommonPrefix (a, b) {
  let i = 0;
  while (i < a.length && i < b.length && (a.charAt(i) === b.charAt(i))) {
    i++
  }
  return i > 0 ? a.substring(0, i) : '';
}
```

时间复杂度: O(n)，最坏情况所有字符串都相同，会比较字符 n 次，n 为字符长度。最好情况所有字符都不相同，需要遍历 n 次，n 为数组长度
空间复杂度: O(1)

### 方法2：循环迭代

公共前缀一定是所有字符串都包含的，可以将任意字符串作为公共前缀，从长度 0 到 n（n 为字符串长度），扫描数组中字符串是否都有该前缀，直到不满足为止

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
const longestCommonPrefix = function (strs) {
  if (strs.length === 0) return '';

  const first = strs[0];
  if (strs.length === 1) return first;

  for (let i = 0; i < first.length; i++) {
    const char = first.charAt(i);

    for (let j = 1; j < strs.length; j++) {
      if ((strs[j].length <= i) || (char !== strs[j].charAt(i))) {
        return first.substring(0, i);
      }
    }
  }

  return first;
};
```

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
const longestCommonPrefix = function (strs) {
  if (strs.length === 0) return '';

  let i = 0;
  let flag = true; // 标记

  while (flag) {
    if (strs[0].length > i) { // 公共前缀的长度不能大于第一个字符串的长度
      const char = strs[0].charAt(i);

      for (let j = 1; j < strs.length; j++) {
        if ((strs[j].length <= i) || (char !== strs[j].charAt(i))) {
          flag = false;
          break;
        }
      }
    } else {
      flag = false;
    }
    i++;
  }

  return strs[0].substring(0, i - 1);
};
```

时间复杂度: O(n)
空间复杂度: O(1)

## 最长回文子串 - 中等

::: warning
[leetcode-5](https://leetcode-cn.com/problems/longest-palindromic-substring/)
:::

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```js
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

输入: "cbbd"
输出: "bb"
```
